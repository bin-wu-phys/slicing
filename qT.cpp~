#include "SampleAnalyzer/User/Analyzer/qT.h"
#include "TCanvas.h"
using namespace MA5;
using namespace std;

// -----------------------------------------------------------------------------
// Initialize
// function called one time at the beginning of the analysis
// -----------------------------------------------------------------------------
bool qT::Initialize(const MA5::Configuration& cfg, const std::map<std::string,std::string>& parameters)
{
  cout << "BEGIN Initialization" << endl;
  // Initializing PhysicsService for MC
  PHYSICS->mcConfig().Reset();


  // Initializing histograms
  _histDphi = new TH1F("_histDphi", "#Delta#phi", 50, 20.0, 200.0);
  _histDphi->GetXaxis()->SetTitle("#Delta#phi");
  
  _histqT = new TH1F("_qT", "q_{T}", 50, 20.0, 200.0);
  _histqT->GetXaxis()->SetTitle("q_{T}[GeV]");

  cout << "END   Initialization" << endl;
  return true;
}

// -----------------------------------------------------------------------------
// Finalize
// function called one time at the end of the analysis
// -----------------------------------------------------------------------------
void qT::Finalize(const SampleFormat& summary, const std::vector<SampleFormat>& files)
{
  cout << "BEGIN Finalization" << endl;
  // Normalization of the histogram: L = 10 fb-1
  double nrm = summary.mc()->xsection() * 10000. /
    static_cast<float>(summary.nevents());
  _histDphi->Scale(nrm); _histqT->Scale(nrm);
  
  //Output
  TCanvas* c1 = new TCanvas("c1","#Delta#phi", 500, 700);
  _histDphi->Draw("HIST");
  c1->SaveAs("Dphi.pdf");

  TCanvas* c2 = new TCanvas("c2","q_{T}", 500, 700);
  _histqT->Draw("HIST");
  c2->SaveAs("qT.pdf");  
  cout << "END   Finalization" << endl;
}

// -----------------------------------------------------------------------------
// Execute
// function called each time one event is read
// -----------------------------------------------------------------------------
bool qT::Execute(SampleFormat& sample, const EventFormat& event)
{
  const MCParticleFormat *Js[3]; int iJ = 0;
  for (MAuint32 i=0;i<event.mc()->particles().size();i++){
    const MCParticleFormat* part = &event.mc()->particles()[i];

    if (PHYSICS->Id->IsFinalState(*part)){
      Js[iJ] = part;
      iJ++;
    }
      /*
      // pdgid
      cout << "pdg id=" << part.pdgid() << endl;
      if (PHYSICS->Id->IsInvisible(part)) cout << " (invisible particle) ";
      else cout << " (visible particle) ";
      cout << endl;

      // display kinematics information
      cout << "px=" << part.px()
                << " py=" << part.py()
                << " pz=" << part.pz()
                << " e="  << part.e()
                << " m="  << part.m() << endl;
      cout << "pt=" << part.pt() 
                << " eta=" << part.eta() 
                << " phi=" << part.phi() << endl;

      // display particle mother id
      if (part.mothers().empty()) 
      {
        cout << "particle with no mother." << endl;
      }
      else
      {
        std::cout << "particle coming from the decay of";
        for(MAuint32 j=0;j<part.mothers().size();j++)
        {
          const MCParticleFormat* mother = part.mothers()[j];
          cout << " " << mother->pdgid();
        }
        std::cout << "." << endl;
      */
  }
  if(iJ!=3){
    cout << "There are " << iJ << " final-state particles?" << endl;
  }else{
    cout << endl;
    for(int i=0;i<3;i++)
      cout << Js[i]->pt() << " ";
    cout << endl;
    
    SortpT(Js);

    for(int i=0;i<3;i++)
      cout << Js[i]->pt() << " ";
    cout << endl;
  }
  
  return true;
}

void qT::SortpT(const MCParticleFormat** Js){
  int iMin=0, iMax=0;
  double pMin = Js[0]->pt(), pMax = Js[0]->pt();
  for(int i=1;i<3;i++){
    if(Js[i]->pt() < pMin){
      iMin = i; pMin = Js[i]->pt();
    }else if(Js[i]->pt() > pMax){
      iMax = i; pMax = Js[i]->pt();
    }
  }

  if(iMax!=iMin){
    const MCParticleFormat *j1 = Js[iMax], *j2, *j3 = Js[iMin];
    for(int i=0;i<3;i++){
      if((i!=iMax)&&(i!=iMin)) j2 = Js[i];
    }
    Js[0] = j1; Js[1] = j2; Js[2] = j3;
  }
}
